"""Fashion trend awareness — 2025 Indian and Western menswear.

Provides a static curated knowledge base (trends_2025.json) with query functions
that filter and format trend context for injection into recommendation prompts.

Architecture decision: static curated JSON rather than runtime web search.
Trends for a season are stable; the file can be regenerated by querying Claude
at the start of each season. No latency, no API cost, no scraping fragility.

Usage:
    from src.fashion_knowledge.trends import get_trend_context_string

    context = get_trend_context_string(
        occasion="smart_casual",
        body_shape="inverted_triangle",
        region="western",
    )
"""

from __future__ import annotations

import json
import logging
from pathlib import Path
from typing import TypedDict

logger = logging.getLogger(__name__)


# ---------------------------------------------------------------------------
# Type definitions
# ---------------------------------------------------------------------------


class TrendEntry(TypedDict):
    """Single trend entry from trends_2025.json."""

    item: str
    """Short label for the trending item."""

    category: str
    """One of: "garment" / "accessory" / "footwear" / "colour" / "grooming"."""

    occasions: list[str]
    """Occasion tags this trend applies to."""

    body_types: list[str]
    """Body type tags this trend specifically flatters. Empty = all body types."""

    region: str
    """"indian" / "western" / "global"."""

    trend_direction: str
    """"rising" / "peak" / "fading"."""

    stylist_note: str
    """One-line expert note for use in recommendations."""


# ---------------------------------------------------------------------------
# Load data
# ---------------------------------------------------------------------------

_DATA_PATH = Path(__file__).parent / "trends_2025.json"
_TRENDS: list[TrendEntry] = []


def _load_trends() -> list[TrendEntry]:
    """Load trends from the JSON file. Returns empty list on any error."""
    global _TRENDS
    if _TRENDS:
        return _TRENDS
    try:
        with open(_DATA_PATH, encoding="utf-8") as fh:
            _TRENDS = json.load(fh)
        logger.debug("Loaded %d trend entries from %s", len(_TRENDS), _DATA_PATH)
    except Exception as exc:
        logger.warning("Could not load trends_2025.json: %s", exc)
        _TRENDS = []
    return _TRENDS


# ---------------------------------------------------------------------------
# Query functions
# ---------------------------------------------------------------------------


def get_trends_for_occasion(
    occasion: str,
    region: str = "global",
) -> list[TrendEntry]:
    """Return all trend entries applicable to an occasion and region.

    Args:
        occasion: Occasion string (e.g. "smart_casual", "indian_formal").
        region: "indian" / "western" / "global" — filters by region.
                "global" returns entries tagged "global" AND the chosen region.

    Returns:
        List of matching TrendEntry dicts, sorted with "peak" first.
    """
    trends = _load_trends()
    occ_lower = occasion.lower().strip()
    reg_lower = region.lower().strip()

    def _matches_region(entry: TrendEntry) -> bool:
        r = entry["region"]
        if reg_lower == "global":
            return True
        return r == reg_lower or r == "global"

    def _matches_occasion(entry: TrendEntry) -> bool:
        if not entry["occasions"]:
            return True
        return any(occ_lower in o.lower() or o.lower() in occ_lower for o in entry["occasions"])

    filtered = [e for e in trends if _matches_occasion(e) and _matches_region(e)]

    # Sort: peak → rising → fading
    _order = {"peak": 0, "rising": 1, "fading": 2}
    filtered.sort(key=lambda e: _order.get(e["trend_direction"], 3))
    return filtered


def get_trending_colors_2025() -> dict[str, list[str]]:
    """Return trending color families grouped by region.

    Returns:
        Dict with keys "indian", "western", "global", each a list of color strings.
    """
    trends = _load_trends()
    result: dict[str, list[str]] = {"indian": [], "western": [], "global": []}

    for entry in trends:
        if entry["category"] == "colour":
            region = entry["region"]
            if region in result:
                result[region].append(entry["item"])

    return result


def get_trend_context_string(
    occasion: str,
    body_shape: str = "",
    region: str = "global",
    max_items: int = 5,
) -> str:
    """Return a formatted trend context block for injection into the recommendation prompt.

    Args:
        occasion: Occasion string.
        body_shape: Body shape value — used to weight body-type-specific entries first.
        region: "indian" / "western" / "global".
        max_items: Maximum number of trend entries to include.

    Returns:
        Formatted multi-line string. Empty string if no relevant trends found.
    """
    entries = get_trends_for_occasion(occasion, region)
    if not entries:
        return ""

    # Weight body-type-specific entries to appear first
    def _priority(entry: TrendEntry) -> int:
        if body_shape and entry["body_types"]:
            if any(body_shape.lower() in bt.lower() for bt in entry["body_types"]):
                return 0   # highest priority — body-type match
        if not entry["body_types"]:
            return 1       # generic — applies to all
        return 2           # body-type-specific but not matching this frame

    entries.sort(key=lambda e: (_priority(e), {"peak": 0, "rising": 1, "fading": 2}.get(e["trend_direction"], 3)))
    entries = entries[:max_items]

    region_label = region.replace("_", " ").title()
    occ_label    = occasion.replace("_", " ").title()
    lines = [f"2025 trends relevant to {occ_label} ({region_label} menswear):"]
    for entry in entries:
        direction_tag = f"({entry['trend_direction']})"
        lines.append(f"  · {entry['item']} {direction_tag} — {entry['stylist_note']}")

    return "\n".join(lines)
